<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
  <meta name='mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-capable' content='yes'>
  <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
  <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
  <link rel='stylesheet' href='css/common.css'>

  <title>Immersive AR Session</title>
  <style>
    /* Style for messages and UI */
    #ar-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      max-width: 80%;
      z-index: 100;
    }

    .launch-button {
      background-color: #0066cc;
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 5px;
      margin-top: 15px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
    }

    #loading-indicator {
      display: inline-block;
      margin-left: 10px;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* App Store Banner styles */
    #dom-overlay-content {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1000;
      pointer-events: none; /* Make the overlay container not block interactions */
      /* Initially hide overlay content until AR session starts */
      display: none;
    }

    #app-store-banner {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px 20px;
      text-align: center;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      pointer-events: auto; /* Make banner elements clickable */
    }

    #app-store-banner p {
      margin: 0 20px 0 0;
      font-size: 16px;
      font-weight: bold;
    }

    .app-store-button {
      background-color: #0066cc;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 5px;
      margin: 0 10px;
      cursor: pointer;
      font-size: 14px;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
    }

    .app-store-button img {
      height: 20px;
      margin-right: 8px;
    }

    #banner-close {
      background-color: transparent;
      color: white;
      border: none;
      font-size: 18px;
      cursor: pointer;
      margin-left: 15px;
      padding: 0 8px;
    }

    /* Show overlay content during XR sessions using the standard pseudoclass */
    #dom-overlay-content:xr-overlay {
      display: block;
    }
  </style>
</head>
<body>
<!-- DOM Overlay container - this will be used as the root for the DOM overlay -->
<div id="dom-overlay-content">
  <!-- App Store Banner -->
  <div id="app-store-banner">
    <p>Get the full experience in our app!</p>
    <a href="https://play.google.com/store/apps/details?id=com.yourcompany.arapp" class="app-store-button" id="android-button">
      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Google_Play_Arrow_logo.svg/1024px-Google_Play_Arrow_logo.svg.png" alt="Google Play">
      Android App
    </a>
    <a href="https://apps.apple.com/us/app/yourapp/id123456789" class="app-store-button" id="ios-button">
      <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/Apple_logo_black.svg/1667px-Apple_logo_black.svg.png" alt="App Store">
      iOS App
    </a>
    <button id="banner-close">Ã—</button>
  </div>
</div>

<!-- Single message box with start button - simplified -->
<div id="ar-message">
  <h2>Start AR Experience</h2>
  <p>Tap the button below to launch AR</p>
  <button id="start-ar-button" class="launch-button">LAUNCH AR</button>
  <div id="loading-indicator" style="display: none;"></div>
</div>

<!-- Include the GCS client -->
<script src="js/xfiti-gcs-client.js"></script>

<script type="module">
  import {WebXRButton} from './js/util/webxr-button.js';
  import {Scene} from './js/render/scenes/scene.js';
  import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
  import {InlineViewerHelper} from './js/util/inline-viewer-helper.js';
  import {Gltf2Node} from './js/render/nodes/gltf2.js';
  import {QueryArgs} from './js/util/query-args.js';

  // If requested, use the polyfill to provide support for mobile devices
  // and devices which only support WebVR.
  import WebXRPolyfill from './js/third-party/webxr-polyfill/build/webxr-polyfill.module.js';
  if (QueryArgs.getBool('usePolyfill', true)) {
    let polyfill = new WebXRPolyfill();
  }

  // XR globals.
  let xrButton = null;
  let xrImmersiveRefSpace = null;
  let inlineViewerHelper = null;

  // WebGL scene globals.
  let gl = null;
  let renderer = null;
  let scene = new Scene();
  scene.enableStats(false);

  // Initialize XfitiGCSClient with your API endpoint and token
  const gcsClient = new XfitiGCSClient(
          'https://platform-dev-s5gmxb6whq-wl.a.run.app/xfiti/signed/asset3d',
          'b9765f944b3c10ccff2961941eedd4228a6eb5ff59c54268efab889d90a234ae'
  );

  // Default model to use if GCS loading fails
  const defaultModelUrl = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/main/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb';

  // Parse the model parameter - this is the ID of the model in XfitiGCSClient
  // For XfitiGCSClient, we just need the ID, not bucket/object format
  const modelParam = QueryArgs.getString('model', 'c3c866dd-f3e1-4b84-8f53-f065868e41a5');
  const useGCS = QueryArgs.getBool('useGCS', true);

  // Variables to hold the parsed values
  let directModelUrl = defaultModelUrl;
  let assetId = '';

  // Parse the model parameter based on mode
  if (useGCS) {
    // For XfitiGCSClient, we just need the model ID
    assetId = modelParam;
    console.log(`Using XfitiGCSClient with model ID: ${assetId}`);
  } else {
    // When useGCS is false, use the model parameter as direct URL
    directModelUrl = modelParam;
    console.log(`Using direct URL: ${directModelUrl}`);
  }

  // Get optional scale parameter, default is 0.5
  const modelScale = QueryArgs.getFloat('scale', 0.5);

  // Get optional position parameters
  const modelX = QueryArgs.getFloat('x', 0.0);
  const modelY = QueryArgs.getFloat('y', 0.0);
  const modelZ = QueryArgs.getFloat('z', -1.0);

  // Model reference to be initialized later
  let model = null;

  // UI elements
  const arMessage = document.getElementById('ar-message');
  const startARButton = document.getElementById('start-ar-button');
  const loadingIndicator = document.getElementById('loading-indicator');
  const domOverlayContent = document.getElementById('dom-overlay-content');
  const bannerClose = document.getElementById('banner-close');

  // Add event listener for banner close button
  bannerClose.addEventListener('click', () => {
    document.getElementById('app-store-banner').style.display = 'none';
  });

  // Create a blob URL from array buffer data
  function createBlobUrlFromArrayBuffer(arrayBuffer, mimeType = 'model/gltf-binary') {
    const blob = new Blob([arrayBuffer], { type: mimeType });
    return URL.createObjectURL(blob);
  }


  // Initialize the 3D model
  async function initializeModel() {
    let modelUrl;

    if (useGCS) {
      try {
        console.log(`Attempting to load model with asset ID: ${assetId}`);
        showLoading(true);
        updateMessage("Loading 3D model...");

        // First get the signed URL
        const signedUrl = await gcsClient.getSignedURL(assetId);
        console.log(`Obtained signed URL: ${signedUrl}`);

        // Verify the URL works with a HEAD request
        const exists = await gcsClient.fileExists(signedUrl);
        console.log('File exist in google cloud bucket');

        if (!exists) {
          console.warn(`Model with asset ID ${assetId} not found, using fallback`);
          showLoading(false);
          modelUrl = defaultModelUrl;
        } else {
          // Download the model file using fetch
          const response = await fetch(signedUrl);
          const modelData = await response.arrayBuffer();
          console.log(`Downloaded model, size: ${modelData.byteLength} bytes`);

          // Create a blob URL from the array buffer
          modelUrl = createBlobUrlFromArrayBuffer(modelData);
          console.log(`Created blob URL for model: ${modelUrl}`);
        }
      } catch (error) {
        console.error('Error loading model from Xfiti:', error);
        modelUrl = defaultModelUrl;
        updateMessage("Failed to load 3D model, using fallback");
      } finally {
        showLoading(false);
      }
    } else {
      console.log(`Using direct model URL: ${directModelUrl}`);
      modelUrl = directModelUrl;
    }

    console.log(`Final model URL: ${modelUrl}`);
    console.log(`Model scale: ${modelScale}`);
    console.log(`Model position: x=${modelX}, y=${modelY}, z=${modelZ}`);

    // Create the model node
    model = new Gltf2Node({
      url: modelUrl
    });

    // Set scale and position based on parameters
    model.scale = [modelScale, modelScale, modelScale];
    model.translation = [modelX, modelY, modelZ];

    scene.addNode(model);

    // Update UI after model is loaded
    updateMessage("Model loaded successfully", "LAUNCH AR");
  }

  // Show or hide loading indicator
  function showLoading(isLoading) {
    loadingIndicator.style.display = isLoading ? 'inline-block' : 'none';
    startARButton.disabled = isLoading;
  }

  function initXR() {
    // Create hidden WebXR button for session management
    xrButton = new WebXRButton({
      onRequestSession: onRequestSession,
      onEndSession: onEndSession,
      textEnterXRTitle: "START AR",
      textXRNotFoundTitle: "AR NOT FOUND",
      textExitXRTitle: "EXIT AR",
    });
    xrButton.domElement.style.display = 'none';
    document.body.appendChild(xrButton.domElement);

    // Basic error checks
    if (!navigator.xr) {
      updateMessage("WebXR not available in this browser", "NOT SUPPORTED");
      return;
    }

    if (!window.isSecureContext) {
      updateMessage("WebXR requires HTTPS", "NOT SUPPORTED");
      return;
    }

    // Set up start button
    startARButton.addEventListener('click', () => {
      arMessage.style.display = 'none';
      startAR();
    });

    // Check if AR is supported (but don't auto-start)
    navigator.xr.isSessionSupported('immersive-ar')
            .then((arSupported) => {
              if (arSupported) {
                xrButton.enabled = true;
                // Initialize the model
                initializeModel();
              } else {
                updateMessage("Your device doesn't support WebXR AR", "NOT SUPPORTED");
                startARButton.disabled = true;
              }
            })
            .catch(error => {
              updateMessage("Error checking AR support: " + error.message, "ERROR");
              console.error(error);
            });
  }

  function updateMessage(message, buttonText) {
    const paragraph = arMessage.querySelector('p');
    if (paragraph) {
      paragraph.textContent = message;
    }

    if (buttonText === "NOT SUPPORTED" || buttonText === "ERROR") {
      startARButton.disabled = true;
      startARButton.textContent = "NOT AVAILABLE";
    } else if (buttonText) {
      startARButton.textContent = buttonText;
    }
  }

  function startAR() {
    // Check if DOM Overlay is supported
    if (navigator.xr && 'dom-overlay' in XRSystem.prototype) {
      console.log('DOM Overlay feature is supported');
    } else {
      console.log('DOM Overlay feature is NOT supported, but will try anyway');
    }

    // Request AR session with DOM overlay explicitly set as required
    const sessionInit = {
      requiredFeatures: ['local-floor'],  // Basic AR
      optionalFeatures: ['dom-overlay'], // DOM overlay as optional to work on more devices
      domOverlay: { root: domOverlayContent } // Specify the overlay root element
    };

    console.log('Requesting session with:', sessionInit);

    navigator.xr.requestSession('immersive-ar', sessionInit)
            .then((session) => {
              console.log("AR session started successfully");

              // Check if DOM Overlay was enabled
              if (session.domOverlayState) {
                console.log(`DOM Overlay enabled! Type: ${session.domOverlayState.type}`);
              } else {
                console.warn("DOM Overlay was requested but is not available");
              }

              xrButton.setSession(session);
              session.isImmersive = true;
              onSessionStarted(session);
            })
            .catch((error) => {
              console.error("Error requesting AR session:", error);

              // Fallback to a session without DOM overlay if that failed
              console.log("Trying without requiring DOM overlay...");
              navigator.xr.requestSession('immersive-ar', {
                requiredFeatures: ['local-floor']
              })
                      .then((session) => {
                        console.log("Fallback AR session started");
                        xrButton.setSession(session);
                        session.isImmersive = true;
                        onSessionStarted(session);
                      })
                      .catch((fallbackError) => {
                        console.error("Error requesting fallback AR session:", fallbackError);
                        arMessage.style.display = 'block';
                        updateMessage("Failed to start AR: " + error.message, "TRY AGAIN");
                      });
            });
  }

  function onRequestSession() {
    // This is called by the WebXRButton internally
    return navigator.xr.requestSession('immersive-ar', {
      requiredFeatures: ['local-floor'],
      optionalFeatures: ['dom-overlay'],
      domOverlay: { root: domOverlayContent }
    });
  }

  function initGL() {
    if (gl) return;

    gl = createWebGLContext({
      xrCompatible: true
    });
    document.body.appendChild(gl.canvas);

    function onResize() {
      gl.canvas.width = gl.canvas.clientWidth * window.devicePixelRatio;
      gl.canvas.height = gl.canvas.clientHeight * window.devicePixelRatio;
    }
    window.addEventListener('resize', onResize);
    onResize();

    renderer = new Renderer(gl);
    scene.setRenderer(renderer);
  }

  function onSessionStarted(session) {
    session.addEventListener('end', onSessionEnded);

    initGL();

    session.updateRenderState({
      baseLayer: new XRWebGLLayer(session, gl)
    });

    let refSpaceType = session.isImmersive ? 'local-floor' : 'viewer';
    session.requestReferenceSpace(refSpaceType).then((refSpace) => {
      if (session.isImmersive) {
        xrImmersiveRefSpace = refSpace;

        xrImmersiveRefSpace.addEventListener('reset', (evt) => {
          if (evt.transform) {
            // AR experiences typically should stay grounded to the real world.
            // If there's a known origin shift, compensate for it here.
            xrImmersiveRefSpace = xrImmersiveRefSpace.getOffsetReferenceSpace(evt.transform);
          }
        });
      } else {
        inlineViewerHelper = new InlineViewerHelper(gl.canvas, refSpace);
      }
      session.requestAnimationFrame(onXRFrame);
    });
  }

  function onEndSession(session) {
    session.end();
  }

  function onSessionEnded(event) {
    if (event.session.isImmersive) {
      xrButton.setSession(null);
      // Show the message when session ends
      arMessage.style.display = 'block';
      updateMessage("AR session ended. Tap to restart.", "LAUNCH AR");
    }
  }

  function positionModelAtCameraHeight(session, frame, model) {
    // Get the viewer pose to determine camera height
    const pose = frame.getViewerPose(xrImmersiveRefSpace);

    if (pose) {
      // Extract the camera height (Y-position) from the viewer pose
      const cameraHeight = pose.transform.position.y - 0.25;

      // Update the model's Y position to match the camera height
      // Keep the X and Z positions as they were
      model.translation = [
        model.translation[0], // Keep X position
        cameraHeight,         // Set Y position to camera height
        model.translation[2]  // Keep Z position
      ];
    }
  }

  // Called every time a XRSession requests that a new frame be drawn.
  function onXRFrame(t, frame) {
    let session = frame.session;
    let refSpace = session.isImmersive ?
            xrImmersiveRefSpace :
            inlineViewerHelper.referenceSpace;
    let pose = frame.getViewerPose(refSpace);

    scene.startFrame();

    session.requestAnimationFrame(onXRFrame);

    if (pose) {
      // Position the model at camera height if it exists
      if (model && session.isImmersive) {
        positionModelAtCameraHeight(session, frame, model);
      }

      scene.drawXRFrame(frame, pose);
    }

    scene.endFrame();
  }

  // Start the XR application.
  initXR();
</script>
</body>
</html>
